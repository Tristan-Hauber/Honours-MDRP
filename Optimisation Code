#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Aug  6 15:43:43 2020

@author: Tristan
"""

import math
from collections import defaultdict
import itertools

courierData = {} # x y ontime offtime
orderData = {} # x y placementtime restaurant readytime latestLeavingTime maxClickToDoorArrivalTime
restaurantData = {} # x y

grubhubInstance = '0o100t75s2p100'
fileDirectory = 'MealDeliveryRoutingGithub/public_instances/' + grubhubInstance + '/'

with open(fileDirectory + 'couriers.txt') as courierDataFile:
    for line in courierDataFile:
        if not line.startswith('courier'):
            data = line.split('\t')
            courierData[int(data[0][1:])] = [int(data[1]), int(data[2]), int(data[3]), int(data[4][:-1])]

with open(fileDirectory + 'orders.txt') as orderDataFile:
    for line in orderDataFile:
        if not line.startswith('order'):
            data = line.split('\t')
            orderData[int(data[0][1:])] = [int(data[1]), int(data[2]), int(data[3]), int(data[4][1:]), int(data[5][:-1])]

with open(fileDirectory + 'restaurants.txt') as restaurantDataFile:
    for line in restaurantDataFile:
        if not line.startswith('restaurant'):
            data = line.split('\t')
            restaurantData[int(data[0][1:])] = [int(data[1]), int(data[2][:-1])]

with open(fileDirectory + 'instance_parameters.txt') as instanceParameters:
    instanceParameters.readline().strip()
    parameters = instanceParameters.readline().strip().split('\t')
    travelSpeed = int(parameters[0]) # metres per minute
    pickupServiceTime = int(parameters[1]) # minutes
    dropoffServiceTime = int(parameters[2]) # minutes
    targetClickToDoor = int(parameters[3]) # minutes
    maxClickToDoor = int(parameters[4]) # minutes
    payPerDelivery = int(parameters[5]) # dollars
    minPayPerHour = int(parameters[6]) # dollars

ordersAtRestaurant = {restaurant: [] for restaurant in restaurantData}
for order in orderData:
    ordersAtRestaurant[orderData[order][3]].append(order)

def TravelTime(loc1, loc2):
    x1, y1 = loc1[0], loc1[1]
    x2, y2 = loc2[0], loc2[1]
    return math.sqrt((x1-x2)**2 + (y1-y2)**2) / travelSpeed

for order in orderData:
    maxClickToDoorArrivalTime = orderData[order][2] + maxClickToDoor
    travelTime = (pickupServiceTime + dropoffServiceTime) / 2 + TravelTime(restaurantData[orderData[order][3]], orderData[order])
    orderData[order].append(maxClickToDoorArrivalTime - travelTime)
    orderData[order].append(maxClickToDoorArrivalTime)

def RemoveDominatedSequences(sequences):
    sequencesBySetAndLastOrder = defaultdict(list)
    for sequence in sequences:
        sequencesBySetAndLastOrder[(frozenset(sequence), sequence[-1])].append(sequence)
    dominatedSequences = set()
    for group in sequencesBySetAndLastOrder:
        if len(sequencesBySetAndLastOrder[group]) > 1:
            for (sequence1, sequence2) in itertools.combinations(sequencesBySetAndLastOrder[group],2):
                if sequences[sequence1][2] > sequences[sequence2][2] and sequences[sequence1][3] < sequences[sequence2][3]:
                    dominatedSequences.add(sequence2)
                elif sequences[sequence1][2] < sequences[sequence2][2] and sequences[sequence1][3] > sequences[sequence2][3]:
                    dominatedSequences.add(sequence1)
    for sequence in dominatedSequences:
        del sequences[sequence]
    return sequences

orderDeliverySequences = {}
# orderSequence: [restaurant, earliestLeavingTime, latestLeavingTime, totalTravelTime]
for restaurant in restaurantData:
    sequenceLength = 1
    calculatedSequences = {}
    for order in ordersAtRestaurant[restaurant]:
        calculatedSequences[(order,)] = [restaurant, orderData[order][4], orderData[order][5], TravelTime(restaurantData[restaurant], orderData[order]) + (pickupServiceTime + dropoffServiceTime) / 2]
    for sequence in calculatedSequences:
        orderDeliverySequences[sequence] = calculatedSequences[sequence]
    while len(calculatedSequences) > 0:
        sequenceLength += 1
        newSequences = {}
        for sequence in calculatedSequences:
            for order in ordersAtRestaurant[restaurant]:
                if order not in sequence:
                    newSequence = sequence + (order,)
                    totalTravelTime = orderDeliverySequences[sequence][3] + dropoffServiceTime + TravelTime(orderData[sequence[-1]], orderData[order])
                    latestLeavingTime = min(orderDeliverySequences[sequence][2], orderData[order][6] - totalTravelTime)
                    earliestLeavingTime = max(orderDeliverySequences[sequence][1], orderData[order][4])
                    if earliestLeavingTime < latestLeavingTime:
                        newSequences[newSequence] = [restaurant, earliestLeavingTime, latestLeavingTime, totalTravelTime]
        if sequenceLength >= 3:
            newSequences = RemoveDominatedSequences(newSequences)
        calculatedSequences = newSequences
        for sequence in calculatedSequences:
            orderDeliverySequences[sequence] = calculatedSequences[sequence]

print(str(len(orderDeliverySequences)) + ' delivery sequences')

sequenceNextRestaurantPairs = {}
for sequence in orderDeliverySequences:
    finishTime = orderDeliverySequences[sequence][1] + orderDeliverySequences[sequence][3]
    for restaurant in restaurantData:
        arrivalAtRestaurant = finishTime + TravelTime(orderData[sequence[-1]], restaurantData[restaurant]) + (dropoffServiceTime + pickupServiceTime) / 2
        for order in ordersAtRestaurant[restaurant]:
            if orderData[order][5] > arrivalAtRestaurant:
                travelTime = orderDeliverySequences[sequence][3] + TravelTime(orderData[sequence[-1]], restaurantData[restaurant]) + (dropoffServiceTime + pickupServiceTime) / 2
                sequenceNextRestaurantPairs[(sequence, restaurant)] = orderDeliverySequences[sequence][:3] + [travelTime]
                break
print(str(len(sequenceNextRestaurantPairs)) + ' pre-domination pairs')

groupedPairs = defaultdict(list)
for pair in sequenceNextRestaurantPairs:
    groupedPairs[frozenset(pair[0]), pair[1]].append(pair[0])
for pair in groupedPairs:
    dominatedSequences = set()
    for (sequence1, sequence2) in itertools.combinations(groupedPairs[pair], 2):
        if sequenceNextRestaurantPairs[(sequence1, pair[1])][2] > sequenceNextRestaurantPairs[(sequence2, pair[1])][2] and sequenceNextRestaurantPairs[(sequence1, pair[1])][3] < sequenceNextRestaurantPairs[(sequence2, pair[1])][3]:
            dominatedSequences.add(sequence2)
        elif sequenceNextRestaurantPairs[(sequence1, pair[1])][2] < sequenceNextRestaurantPairs[(sequence2, pair[1])][2] and sequenceNextRestaurantPairs[(sequence1, pair[1])][3] > sequenceNextRestaurantPairs[(sequence2, pair[1])][3]:
            dominatedSequences.add(sequence1)
    for sequence in dominatedSequences:
        del sequenceNextRestaurantPairs[(sequence, pair[1])]
print(str(len(sequenceNextRestaurantPairs)) + ' post-domination pairs')
